#pragma kernel Update

struct Agent {
    float2 position;
    float angle;
};

RWTexture2D<float4> TrailMap;
RWStructuredBuffer<Agent> agents;

float PI;
float deltaTime;
float moveSpeed;
float sensorOffsetDistance;
float sensorAngleDegrees;
float time;
float turnSpeed;

uint numAgents;
uint width;
uint height;
uint sensorSize;

uint hash(uint state) {
    state ^= 2747636419u;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    return state;
}

float scaleToRange01(uint random)
{
    return random / 4294967295.0f;
}

float sense(Agent agent, float sensorOffset)
{
    float sensorAngle = agent.angle + sensorOffset;
    float2 sensorDir = float2(cos(sensorAngle), sin(sensorAngle));
    
    float2 sensorPos = agent.position + sensorDir * sensorOffsetDistance;
    int sensorCenterX = (int) sensorPos.x;
    int sensorCenterY = (int) sensorPos.y;
    
    float sum = 0;
    
    for (int offsetX = -2; offsetX <= 2; offsetX++)
    {
        for (int offsetY = -2; offsetY <= 2; offsetY++)
        {
            int sampleX = min(width - 1, max(0, sensorCenterX + offsetX));
            int sampleY = min(height - 1, max(0, sensorCenterY + offsetY));
            sum += TrailMap[int2(sampleX, sampleY)];
        }
    }

    return sum;

}

[numthreads(16, 1, 1)]
void Update(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numAgents)
    {
        return;
    }
        
    Agent agent = agents[id.x];
    float2 pos = agent.position;
    
    uint random = hash(pos.y * width + pos.x + hash(id.x + 10000 * time));

    float sensorAngleRad = sensorAngleDegrees * PI / 180;
    
    float weightForward = sense(agent, 0);
    float weightLeft = sense(agent, -sensorAngleRad);
    float weightRight = sense(agent, sensorAngleRad);
    
    float randomSteerStrength = scaleToRange01(random);
    
    if (weightForward > weightLeft && weightForward > weightRight)
    {
        agents[id.x].angle += 0;
    }
    else if (weightForward < weightLeft && weightForward < weightRight)
    {
        agents[id.x].angle += (randomSteerStrength - 0.5) * 2 * turnSpeed * deltaTime;
    }
    else if (weightRight > weightLeft)
    {
        agents[id.x].angle += randomSteerStrength * turnSpeed * deltaTime;
    }
    else if (weightLeft > weightRight)
    {
        agents[id.x].angle -= randomSteerStrength * turnSpeed * deltaTime;
    }
    
    float2 direction = float2(cos(agent.angle), sin(agent.angle));
    float2 newPos = pos + direction * moveSpeed * deltaTime;

    if (newPos.x < 0 || newPos.x >= width || newPos.y < 0 || newPos.y >= height) {
        random = hash(random);
        newPos.x = min(width - 0.01, max(0, newPos.x));
        newPos.y = min(height - 0.01, max(0, newPos.y));
        agents[id.x].angle = scaleToRange01(random) * 2 * PI;
    }

    agents[id.x].position = newPos;
    TrailMap[int2(newPos.x, newPos.y)] = 1;
}

#pragma kernel Diffuse

float diffuseSpeed;
float decayRate;
RWTexture2D<float4> DiffuseMap;

[numthreads(8,8,1)]
void Diffuse(uint3 id : SV_DispatchThreadID)
{
    if (id.x < 0 || id.x >= (uint) width || id.y < 0 || id.y >= (uint) height)
    {
        return;
    }

    float4 sum = 0;
    float4 originalValue = TrailMap[id.xy];
    
    for (int offsetX = -1; offsetX <= 1; offsetX++)
    {
        for (int offsetY = -1; offsetY <= 1; offsetY++)
        {
            int sampleX = min(width - 1, max(0, id.x + offsetX));
            int sampleY = min(height - 1, max(0, id.y + offsetY));
            sum += TrailMap[int2(sampleX, sampleY)];
        }
    }
    
    float4 blurredValue = sum / 9.0;
    float diffuseWeight = saturate(diffuseSpeed * deltaTime);
    blurredValue = originalValue * (1 - diffuseWeight) + blurredValue * (diffuseWeight);
    
    DiffuseMap[id.xy] = blurredValue * saturate(1 - decayRate * deltaTime);
}